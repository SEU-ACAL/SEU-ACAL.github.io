{"title":"Coremark Tutorial","uid":"57b545b4863426c32645601dccb5ab7b","slug":"coremark tutorial","date":"2024-03-18T10:49:37.000Z","updated":"2024-03-18T14:38:03.572Z","comments":true,"path":"api/articles/coremark tutorial.json","keywords":null,"cover":"http://10.201.101.77/img/logo.png","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>CoreMark是由EEMBC(Embedded Microprocessor Benchmark Consortium)的Shay Gla-On于2009年提出的一项基准测试程序，CoreMark的主要目标是简化操作，并提供一套测试单核处理器核心的方法。</p>\n<p>测试标准是在配置参数的组合下单位时间内运行的CoreMark程序次数（单位：CoreMark&#x2F;MHz），该数字值越大则说明测试的性能越好。</p>\n<p>CoreMark是一个简单但复杂的基准测试，专门设计用于测试处理器核心的功能。运行CoreMark会生成一个单一的评分，使用户能够快速比较处理器之间的差异。目前嵌入式CPU行业中普遍公认的性能测试指标包括：MIPS&#x2F;Dhrystone&#x2F;CoreMark。<br>与Dhrystone类似，CoreMark也是小巧、便携、易于理解、免费，并且显示一个单一的基准测试分数。与Dhrystone不同的是，CoreMark有特定的运行和报告规则，并且旨在避免Dhrystone存在的问题，即由于使用的编译库不同而导致测试结果难以比较。</p>\n<p>例如，Dhrystone的主要部分实际上是展示了编译器优化工作负载的能力，而不是MCU或CPU的能力。因此，Dhrystone更多地被用作编译器基准测试，而不是硬件基准测试。</p>\n<p>同样，在Dhrystone的计时部分内部进行库调用。通常，这些库调用会占据基准测试消耗时间的大部分。由于库代码不是基准测试的一部分，如果使用不同的库进行比较，很难得出准确结果。最后，关于如何运行Dhrystone存在一些指导方针，但由于结果没有经过认证或验证，这些指南并不强制执行。关于如何报告Dhrystone结果也没有标准化，存在着各种不同的格式（如DMIPS、每秒Dhrystones、DMIPS&#x2F;MHz）。</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><p>根据eembc官方说的方法，如果想要在risc-v运行toolchain，需要在core_portme.c&#x2F;.h&#x2F;.mak这几个源文件作修改。</p>\n<h2 id=\"源码阅读\"><a href=\"#源码阅读\" class=\"headerlink\" title=\"源码阅读\"></a>源码阅读</h2><p>从coremark_main.c开始阅读：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//内存分配 包括stack/static/malloc三种方式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> (MEM_METHOD==MEM_STACK)</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span> ; i&lt;MULTITHREAD; i++) &#123;</span><br><span class=\"line\">                results[i].memblock[<span class=\"number\">0</span>]=stack_memblock+i*TOTAL_DATA_SIZE;</span><br><span class=\"line\">                results[i].size=TOTAL_DATA_SIZE;</span><br><span class=\"line\">                results[i].seed1=results[<span class=\"number\">0</span>].seed1;</span><br><span class=\"line\">                results[i].seed2=results[<span class=\"number\">0</span>].seed2;</span><br><span class=\"line\">                results[i].seed3=results[<span class=\"number\">0</span>].seed3;</span><br><span class=\"line\">                results[i].err=<span class=\"number\">0</span>;</span><br><span class=\"line\">                results[i].execs=results[<span class=\"number\">0</span>].execs;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 初始化3个benchmark */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span> ; i&lt;MULTITHREAD; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (results[i].execs &amp; ID_LIST) &#123;</span><br><span class=\"line\">                        results[i].<span class=\"built_in\">list</span>=core_list_init(results[<span class=\"number\">0</span>].size,results[i].memblock[<span class=\"number\">1</span>],results[i].seed1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (results[i].execs &amp; ID_MATRIX) &#123;</span><br><span class=\"line\">                        core_init_matrix(results[<span class=\"number\">0</span>].size, results[i].memblock[<span class=\"number\">2</span>], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) &lt;&lt; <span class=\"number\">16</span>), &amp;(results[i].mat) );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (results[i].execs &amp; ID_STATE) &#123;</span><br><span class=\"line\">                        core_init_state(results[<span class=\"number\">0</span>].size,results[i].seed1,results[i].memblock[<span class=\"number\">3</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 自动确定迭代次数 至少10s */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (results[<span class=\"number\">0</span>].iterations==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                secs_ret secs_passed=<span class=\"number\">0</span>;</span><br><span class=\"line\">                ee_u32 divisor;</span><br><span class=\"line\">                results[<span class=\"number\">0</span>].iterations=<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (secs_passed &lt; (secs_ret)<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        results[<span class=\"number\">0</span>].iterations*=<span class=\"number\">10</span>;</span><br><span class=\"line\">                        start_time();</span><br><span class=\"line\">                        iterate(&amp;results[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                        stop_time();</span><br><span class=\"line\">                        secs_passed=time_in_secs(get_time());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* now we know it executes for at least 1 sec, set actual run time at about 10 secs */</span></span><br><span class=\"line\">                divisor=(ee_u32)secs_passed;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (divisor==<span class=\"number\">0</span>) <span class=\"comment\">/* some machines cast float to int as 0 since this conversion is not defined by ANSI, but we know at least one second passed */</span></span><br><span class=\"line\">                        divisor=<span class=\"number\">1</span>;</span><br><span class=\"line\">                results[<span class=\"number\">0</span>].iterations*=<span class=\"number\">1</span>+<span class=\"number\">10</span>/divisor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据不同CRC统计值得到不同的执行模式，2k/6k/profile/performance/validata</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (seedcrc) &#123; <span class=\"comment\">/* test known output for common seeds */</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0x8a02</span>: <span class=\"comment\">/* seed1=0, seed2=0, seed3=0x66, size 2000 per algorithm */</span></span><br><span class=\"line\">                        known_id=<span class=\"number\">0</span>;</span><br><span class=\"line\">                        ee_printf(<span class=\"string\">&quot;6k performance run parameters for coremark.\\n&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0x7b05</span>: <span class=\"comment\">/*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 2000 per algorithm */</span></span><br><span class=\"line\">                        known_id=<span class=\"number\">1</span>;</span><br><span class=\"line\">                        ee_printf(<span class=\"string\">&quot;6k validation run parameters for coremark.\\n&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0x4eaf</span>: <span class=\"comment\">/* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm */</span></span><br><span class=\"line\">                        known_id=<span class=\"number\">2</span>;</span><br><span class=\"line\">                        ee_printf(<span class=\"string\">&quot;Profile generation run parameters for coremark.\\n&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0xe9f5</span>: <span class=\"comment\">/* seed1=0, seed2=0, seed3=0x66, size 666 per algorithm */</span></span><br><span class=\"line\">                        known_id=<span class=\"number\">3</span>;</span><br><span class=\"line\">                        ee_printf(<span class=\"string\">&quot;2K performance run parameters for coremark.\\n&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0x18f2</span>: <span class=\"comment\">/*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 666 per algorithm */</span></span><br><span class=\"line\">                        known_id=<span class=\"number\">4</span>;</span><br><span class=\"line\">                        ee_printf(<span class=\"string\">&quot;2K validation run parameters for coremark.\\n&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                        total_errors=<span class=\"number\">-1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 打印结果 */</span></span><br><span class=\"line\">        ee_printf(<span class=\"string\">&quot;CoreMark Size    : %lu\\n&quot;</span>, (<span class=\"type\">long</span> <span class=\"type\">unsigned</span>) results[<span class=\"number\">0</span>].size);</span><br><span class=\"line\">        ee_printf(<span class=\"string\">&quot;Total ticks      : %lu\\n&quot;</span>, (<span class=\"type\">long</span> <span class=\"type\">unsigned</span>) total_time);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> HAS_FLOAT</span></span><br><span class=\"line\">        ee_printf(<span class=\"string\">&quot;Total time (secs): %f\\n&quot;</span>,time_in_secs(total_time));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (time_in_secs(total_time) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                ee_printf(<span class=\"string\">&quot;Iterations/Sec   : %f\\n&quot;</span>,default_num_contexts*results[<span class=\"number\">0</span>].iterations/time_in_secs(total_time));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">        ee_printf(<span class=\"string\">&quot;Total time (secs): %d\\n&quot;</span>,time_in_secs(total_time));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (time_in_secs(total_time) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                ee_printf(<span class=\"string\">&quot;Iterations/Sec   : %d\\n&quot;</span>,default_num_contexts*results[<span class=\"number\">0</span>].iterations/time_in_secs(total_time));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (time_in_secs(total_time) &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                ee_printf(<span class=\"string\">&quot;ERROR! Must execute for at least 10 secs for a valid result!\\n&quot;</span>);</span><br><span class=\"line\">                total_errors++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​coremark.h</p>\n<p>call_bench_list&#x2F;matrix&#x2F;state()是benchmark的执行函数，和result[i].exe一起控制测试程序的执行</p>\n<p>coremark_list_join.c&#x2F;matrix.c&#x2F;state.c&#x2F;util.c分别为各自benchmark和CRC函数所在的源文件</p>\n<p>core_portme.c修改的地方</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* setting to 1/1000 of a second resolution by default with linux */</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">ifndef</span> TIMER_RES_DIVIDER</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> TIMER_RES_DIVIDER 1000000</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> SAMPLE_TIME_IMPLEMENTATION 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 加入RISCV部分</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">define</span> NSECS_PER_SEC 500000000 </span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> EE_TIMER_TICKER_RATE 1000 </span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> CORETIMETYPE clock_t</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">define</span> read_csr(reg) (&#123; unsigned long __tmp; \\</span></span><br><span class=\"line\"><span class=\"meta\">       asm volatile (<span class=\"string\">&quot;csrr %0, &quot;</span> #reg : <span class=\"string\">&quot;=r&quot;</span>(__tmp)); \\</span></span><br><span class=\"line\"><span class=\"meta\">       __tmp; &#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">define</span> GETMYTIME(_t) (*_t=read_csr(cycle))<span class=\"comment\">//通过读时钟周期计数</span></span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> MYTIMEDIFF(fin,ini) ((fin)-(ini))</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> TIMER_RES_DIVIDER 1</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> SAMPLE_TIME_IMPLEMENTATION 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)</span></span><br></pre></td></tr></table></figure>\n<p>这段代码是一个条件编译块，用于设置不同平台上计时器分辨率和实现细节。不同的编译分支适用于Linux系统和RISCV架构。其中包括cpu频率和定时器频率的设置，根据具体硬件特性确定。</p>\n<p>core_portme.h修改的地方</p>\n<ul>\n<li>如果定义了宏HAS_TIME_H，这表明该平台具有并支持time.h标准C库头文件。在这个分支中，CORE_TICKS被定义为clock_t，这是time.h中定义的一个类型，通常用于计算程序占用的处理器时间。但是RISCV-baremetal不用标准库，用newlabc</li>\n<li>手动定义了size_t和clock_t为unsigned long int类型，并将CORE_TICKS设置为clock_t。用于baremetal，这些类型的大小需要匹配处理器输出的时钟大小和处理器支持的位数（xLen）。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Configuration: CORE_TICKS</span></span><br><span class=\"line\"><span class=\"comment\">        Define type of return from the timing functions.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(_MSC_VER)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">size_t</span> CORE_TICKS;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> HAS_TIME_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">clock_t</span> CORE_TICKS;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"comment\">/* Configuration: size_t and clock_t</span></span><br><span class=\"line\"><span class=\"comment\">     Note these need to match the size of the clock output and the xLen the processor supports</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">int</span> <span class=\"type\">size_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">int</span> <span class=\"type\">clock_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">clock_t</span> CORE_TICKS;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>core_portme.mak修改的地方</p>\n<p>设置RISCV工具链和路径，编译选项不变</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Flag: RISCVTOOLS</span><br><span class=\"line\">#       Use this flag to point to your RISCV tools</span><br><span class=\"line\">RISCVTOOLS=$(RISCV)</span><br><span class=\"line\"># Flag: RISCVTYPE</span><br><span class=\"line\">#   Type of toolchain to use</span><br><span class=\"line\">RISCVTYPE=riscv64-unknown-elf</span><br><span class=\"line\"># Flag: OUTFLAG</span><br><span class=\"line\">#       Use this flag to define how to to get an executable (e.g -o)</span><br><span class=\"line\">OUTFLAG= -o</span><br><span class=\"line\"># Flag: CC</span><br><span class=\"line\">#       Use this flag to define compiler to use</span><br><span class=\"line\">CC = $(RISCVTOOLS)/bin/$(RISCVTYPE)-gcc</span><br><span class=\"line\"># Flag: CFLAGS</span><br><span class=\"line\">#       Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS=<span class=\"string\">&quot;other flags&quot;</span></span><br><span class=\"line\">#PORT_CFLAGS = -O2 -<span class=\"type\">static</span> -<span class=\"built_in\">std</span>=gnu99</span><br><span class=\"line\">PORT_CFLAGS = -O2</span><br><span class=\"line\">FLAGS_STR = <span class=\"string\">&quot;$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)&quot;</span></span><br><span class=\"line\">CFLAGS = $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\\<span class=\"string\">&quot;$(FLAGS_STR)\\&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></table></figure>\n<p>跑10000000cycle，需要大概50min，跑通100次iteration，91830000cycle，大概需要460min&#x3D;7小时40min。跑通了coremark，接下来需要加速跑的时间和利用它来评估设计（比如cache miss rate），要进一步看懂code。</p>\n<p>总结一下遇到的问题，解决的方法和完成的工作：</p>\n<p>1.用gdb跑了一遍在Linux上跑的coremark，熟悉代码；</p>\n<p>2.遇到的问题：</p>\n<p>a.仿真停在某一条指令，停在一条很正常的函数ret的压栈出栈指令。</p>\n<p>-&gt;看rocket code，结合波形，发现是id_is_returngood的问题，之前师兄熟悉rocket代码加的指令，删掉就可以继续跑了；</p>\n<p>b.跑到10000001cycle之后，不能继续跑。</p>\n<p>-&gt;看.out输出 failed，没有正常退出，看.make_coremark.log(makefile输出的)报错，timeout，定位到test_driver.v函数，发现是max_cycle到极限了。如何改max_cycle？去看makefile，即可定位到variable.mak文件里面的CFLAGS变量，在里面修改timeout_cycles的值为100000000即可，实测90000000cycle，iterate 100 times，结果是可以的。</p>\n<p>c.结果的tick value得到了，但是sec value没有得到，应该是time_in_secs函数出问题了，到portme.c文件去找问题。log是sec没有10 s</p>\n<p>从portme.c可得，1000000000ticks&#x3D;1s,45589522ticks&#x3D;0.05s左右，也就是50ms.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">define</span> NSECS_PER_SEC 1000000000 <span class=\"comment\">// normal</span></span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> EE_TIMER_TICKER_RATE 1000 <span class=\"comment\">// set for 1ms</span></span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> CORETIMETYPE clock_t</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">define</span> read_csr(reg) (&#123; unsigned long __tmp; \\</span></span><br><span class=\"line\"><span class=\"meta\">       asm volatile (<span class=\"string\">&quot;csrr %0, &quot;</span> #reg : <span class=\"string\">&quot;=r&quot;</span>(__tmp)); \\</span></span><br><span class=\"line\"><span class=\"meta\">       __tmp; &#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">define</span> GETMYTIME(_t) (*_t=read_csr(cycle))</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> MYTIMEDIFF(fin,ini) ((fin)-(ini))</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> TIMER_RES_DIVIDER 1</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">define</span> SAMPLE_TIME_IMPLEMENTATION 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3.可以深入探究的：</p>\n<p>a.bare-metal怎么实现内存分配的？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">(gdb) n</span><br><span class=\"line\">143\t\t\t\tresults[i].size=malloc_override;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">146\t\t\tresults[i].memblock[0]=portable_malloc(results[i].size);</span><br><span class=\"line\">(gdb) info locals</span><br><span class=\"line\">malloc_override = 2000</span><br><span class=\"line\">i = 0</span><br><span class=\"line\">j = 0</span><br><span class=\"line\">num_algorithms = 0</span><br><span class=\"line\">known_id = -1</span><br><span class=\"line\">total_errors = 0</span><br><span class=\"line\">seedcrc = 0</span><br><span class=\"line\">total_time = &lt;optimized out&gt;</span><br><span class=\"line\">results = &#123;&#123;seed1 = 0, seed2 = 0, seed3 = 102, memblock = &#123;0x0, 0x0, 0x0, 0x7fffffffde00&#125;, size = 2000, iterations = 0, execs = 7, list = 0x7ffff78abd8d &lt;intel_check_word+173&gt;, </span><br><span class=\"line\">    mat = &#123;N = 8388608, A = 0xffffffffffffffff, B = 0x7ffff75ef8f0 &lt;sighandler_setxid&gt;, C = 0xf0&#125;, crc = 1, crclist = 0, crcmatrix = 0, crcstate = 0, err = 9101, port = &#123;</span><br><span class=\"line\">      portable_id = 1 <span class=\"string\">&#x27;\\001&#x27;</span>&#125;&#125;&#125;</span><br><span class=\"line\">(gdb) s</span><br><span class=\"line\">portable_malloc (size=2000) at linux64/core_portme.c:32</span><br><span class=\"line\">32\t\t<span class=\"built_in\">return</span> malloc(size);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>linux是通过上述过程实现的，也就是melloc()函数，分配给的size空间为2000.</p>\n<p>如果想要知道bare-metal怎么分配内存，可能要去看.out和.dump结合理解，好麻烦，，，后面看吧</p>\n<p>b.bare-metal怎么用定时器计数的？没有syscall&#x2F;ecall的情况下（如果有rt-thread类似简单的os有ecall）</p>\n<p>上述代码定义了csrr内联汇编指令，可以读取寄存器的值得到cycle。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">//gdb debug</span><br><span class=\"line\">(gdb) bt</span><br><span class=\"line\"><span class=\"comment\">#0  main (argc=8, argv=0x7fffffffdee8) at core_main.c:203</span></span><br><span class=\"line\">(gdb) s</span><br><span class=\"line\">start_time () at linux64/core_portme.c:125</span><br><span class=\"line\">125\t\tGETMYTIME(&amp;start_time_val );      </span><br><span class=\"line\">(gdb) s</span><br><span class=\"line\">__GI___clock_gettime (clock_id=0, tp=0x6040b0 &lt;start_time_val&gt;) at ../sysdeps/unix/clock_gettime.c:93</span><br><span class=\"line\">(gdb) s</span><br><span class=\"line\">115\t      SYSDEP_GETTIME_CPU (clock_id, tp);</span><br><span class=\"line\"></span><br><span class=\"line\">//get secs</span><br><span class=\"line\">secs_ret time_in_secs(CORE_TICKS ticks) &#123;</span><br><span class=\"line\">        secs_ret retval=((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;</span><br><span class=\"line\">        return retval;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">CORE_TICKS get_time(void) &#123;</span><br><span class=\"line\">        CORE_TICKS elapsed=(CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));</span><br><span class=\"line\">        <span class=\"built_in\">return</span> elapsed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//RISCV-baremetal</span><br><span class=\"line\">   <span class=\"comment\">#define read_csr(reg) (&#123; unsigned long __tmp; \\</span></span><br><span class=\"line\">       asm volatile (<span class=\"string\">&quot;csrr %0, &quot;</span> <span class=\"comment\">#reg : &quot;=r&quot;(__tmp)); \\</span></span><br><span class=\"line\">       __tmp; &#125;)</span><br><span class=\"line\">    <span class=\"comment\">#define GETMYTIME(_t) (*_t=read_csr(cycle))</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>c.里面有3个子workload，执行过程是什么样的？</p>\n<p>全跑的话，results[0].exes value是7。如果想要只执行某一个，设置这个参数就可以了。</p>\n<p>而且，与猜想的一样，bench_list就是整理3个benchmark的数据，里面可以跳转到calc_func执行matrix_cal和state_cal。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">83</span> <span class=\"comment\">/* Algorithm IDS */</span></span><br><span class=\"line\"><span class=\"number\">84</span> <span class=\"meta\">#<span class=\"keyword\">define</span> ID_LIST         (1&lt;&lt;0)</span></span><br><span class=\"line\"><span class=\"number\">85</span> <span class=\"meta\">#<span class=\"keyword\">define</span> ID_MATRIX       (1&lt;&lt;1)</span></span><br><span class=\"line\"><span class=\"number\">86</span> <span class=\"meta\">#<span class=\"keyword\">define</span> ID_STATE        (1&lt;&lt;2)</span></span><br><span class=\"line\"><span class=\"number\">87</span> <span class=\"meta\">#<span class=\"keyword\">define</span> ALL_ALGORITHMS_MASK (ID_LIST|ID_MATRIX|ID_STATE)</span></span><br><span class=\"line\"><span class=\"number\">88</span> <span class=\"meta\">#<span class=\"keyword\">define</span> NUM_ALGORITHMS 3</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/direct/d027c7559a9c4dbca5b22547c8e4ad58.png#pic_center\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/direct/5cef0796a98448d58211557b40bf22b2.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n","feature":true,"text":"背景CoreMark是由EEMBC(Embedded Microprocessor Benchmark Consortium)的Shay Gla-On于2009...","permalink":"/post/coremark tutorial","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"文档","slug":"文档","count":3,"path":"api/categories/文档.json"}],"tags":[{"name":"文档","slug":"文档","count":3,"path":"api/tags/文档.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">使用方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB\"><span class=\"toc-text\">源码阅读</span></a></li></ol>","author":{"name":"rain","slug":"rain","avatar":"https://seu-acal.github.io/img/logo.png","link":"https://github.com/Derain123","description":"dean you.","socials":{}},"mapped":true,"hidden":false,"prev_post":{"title":"团队介绍","uid":"5c35d540ac2f509d17127af1377686ea","slug":"introduction","date":"2024-03-18T10:49:40.000Z","updated":"2024-03-18T19:35:11.545Z","comments":true,"path":"api/articles/introduction.json","keywords":null,"cover":"http://10.201.101.77/img/cover1.jpg","text":"团队介绍 我们是一支年轻的计算机体系结构和系统安全研究团队，致力于推动技术进步，应对复杂系统的挑战，创造更安全、高效、可靠的硬件环境，为中国的芯片发展做出更多有...","permalink":"/post/introduction","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"文档","slug":"文档","count":3,"path":"api/categories/文档.json"}],"tags":[{"name":"文档","slug":"文档","count":3,"path":"api/tags/文档.json"}],"author":{"name":"SEU-ACAL","slug":"blog-author","avatar":"https://seu-acal.github.io/img/logo.png","link":"/","description":"东南大学先进计算机体系结构团队(Southeast University Adavanced Computer Architecture Lab)","socials":{"github":"https://github.com/SEU-ACAL","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2024-03-18T10:49:30.000Z","updated":"2024-03-18T14:38:18.984Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":"http://10.201.101.77/img/logo.png","text":"Welcome to Hexo! This is your very first post. Check documentation for more info...","permalink":"/post/hello-world","photos":[],"count_time":{"symbolsCount":440,"symbolsTime":"1 mins."},"categories":[{"name":"文档","slug":"文档","count":3,"path":"api/categories/文档.json"}],"tags":[{"name":"文档","slug":"文档","count":3,"path":"api/tags/文档.json"}],"author":{"name":"shiroha","slug":"shiroha","avatar":"https://seu-acal.github.io/img/avatar/mio.png","link":"https://github.com/shirohasuki","description":"shiroha.","socials":{}},"feature":true}}