[{"id":"5c35d540ac2f509d17127af1377686ea","title":"团队介绍","content":"团队介绍  我们是一支年轻的计算机体系结构和系统安全研究团队，致力于推动技术进步，应对复杂系统的挑战，创造更安全、高效、可靠的硬件环境，为中国的芯片发展做出更多有意义的工作。\n  我们欢迎有明确目标、学习热情和行动力的你加入我们，与我们一起探索、学习和成长。无论你是热衷于学术研究，还是想将理论付诸实践；无论你是希望深入研究新的计算架构，设计创新的CPU硬件，开发高效的嵌入式操作系统，还是探索实时操作系统和系统安全保障领域，我们都期待与你合作，共同追求计算机技术的前沿。\n  我们的团队正在快速发展，如果你对我们的研究领域感兴趣，或想了解更多信息，请投简历或联系：&#x31;&#48;&#x31;&#x30;&#x31;&#x33;&#x36;&#x31;&#53;&#64;&#115;&#x65;&#117;&#46;&#x65;&#100;&#117;&#46;&#x63;&#x6e;或&#x7a;&#x68;&#x65;&#106;&#x69;&#97;&#110;&#x67;&#x2e;&#x61;&#114;&#x63;&#104;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;\n招生情况课题组常年招收硕士生博士生，欢迎对以下方向具有浓厚兴趣的学生联系，组内经费充足，资源丰富！另外，如想在本科期间进组历练的同学也可与我联系！（&#49;&#x30;&#49;&#48;&#49;&#x33;&#x36;&#x31;&#53;&#64;&#115;&#101;&#117;&#x2e;&#101;&#100;&#x75;&#46;&#99;&#110;或&#122;&#104;&#x65;&#106;&#x69;&#97;&#x6e;&#x67;&#46;&#x61;&#114;&#x63;&#x68;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;）\n\n计算机体系结构与SoC设计：从事计算机体系结构和片上系统设计的学习和研究，致力于为国内芯片领域提供完善的设计以及时序安全、信息安全、功能安全等全面的技术支持，与业内专家进行沟通和交流。芯片设计是当前计算机领域的热点，也是社会上的“卡脖子问题”，团队在该领域有一定的技术积累，填补国内相关领域的空白，并努力将研究成果应用于我国各领域的系统中。\n本科专业：计算机科学与技术、微电子等。\n基础知识：计算机体系结构、数字电路、嵌入式系统等；编程能力；英语能力。\n\n-实时操作系统（Real-time System）协议优化与应用：从事实时系统、操作系统领域的理论与应用研究，旨在围绕操作系统，为上层应用提供高性能、硬实时的计算与通讯保障，与业内专家进行沟通和交流。实时安全是当前安全领域的热点，团队在该领域有一定的技术积累，希望在系统资源共享与管理、硬软件协同设计与寻优等结合方向上寻求全新的突破点。\n本科专业：计算机科学与技术、软件工程、微电子、应用数学等。\n基础知识：计算机体系结构、操作系统、嵌入式系统等；编程能力；英语能力；基础数学能力。\n\n-系统安全保障：从事系统安全领域的学习和研究，参与安全硬件等方面的研究工作，致力于研究基于体系结构的系统安全保障前沿技术，与业内专家进行沟通和交流。系统安全保障是当下几乎所有系统的强需求，团队希望通过为系统增加信息安全、时序安全、功能安全以增加系统的稳定性和安全性。\n本科专业：计算机科学与技术、软件工程、微电子、应用数学等。\n基础知识：面向对象编程、信息安全标准、功能安全标准等；编程能力；英语能力。\n","slug":"introduction","date":"2024-03-18T10:49:40.000Z","categories_index":"文档","tags_index":"文档","author_index":"SEU-ACAL"},{"id":"57b545b4863426c32645601dccb5ab7b","title":"Coremark Tutorial","content":"背景CoreMark是由EEMBC(Embedded Microprocessor Benchmark Consortium)的Shay Gla-On于2009年提出的一项基准测试程序，CoreMark的主要目标是简化操作，并提供一套测试单核处理器核心的方法。\n测试标准是在配置参数的组合下单位时间内运行的CoreMark程序次数（单位：CoreMark&#x2F;MHz），该数字值越大则说明测试的性能越好。\nCoreMark是一个简单但复杂的基准测试，专门设计用于测试处理器核心的功能。运行CoreMark会生成一个单一的评分，使用户能够快速比较处理器之间的差异。目前嵌入式CPU行业中普遍公认的性能测试指标包括：MIPS&#x2F;Dhrystone&#x2F;CoreMark。与Dhrystone类似，CoreMark也是小巧、便携、易于理解、免费，并且显示一个单一的基准测试分数。与Dhrystone不同的是，CoreMark有特定的运行和报告规则，并且旨在避免Dhrystone存在的问题，即由于使用的编译库不同而导致测试结果难以比较。\n例如，Dhrystone的主要部分实际上是展示了编译器优化工作负载的能力，而不是MCU或CPU的能力。因此，Dhrystone更多地被用作编译器基准测试，而不是硬件基准测试。\n同样，在Dhrystone的计时部分内部进行库调用。通常，这些库调用会占据基准测试消耗时间的大部分。由于库代码不是基准测试的一部分，如果使用不同的库进行比较，很难得出准确结果。最后，关于如何运行Dhrystone存在一些指导方针，但由于结果没有经过认证或验证，这些指南并不强制执行。关于如何报告Dhrystone结果也没有标准化，存在着各种不同的格式（如DMIPS、每秒Dhrystones、DMIPS&#x2F;MHz）。\n使用方法根据eembc官方说的方法，如果想要在risc-v运行toolchain，需要在core_portme.c&#x2F;.h&#x2F;.mak这几个源文件作修改。\n源码阅读从coremark_main.c开始阅读：\n//内存分配 包括stack/static/malloc三种方式#elif (MEM_METHOD==MEM_STACK)        for (i=0 ; i&lt;MULTITHREAD; i++) &#123;                results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;                results[i].size=TOTAL_DATA_SIZE;                results[i].seed1=results[0].seed1;                results[i].seed2=results[0].seed2;                results[i].seed3=results[0].seed3;                results[i].err=0;                results[i].execs=results[0].execs;        &#125;/* 初始化3个benchmark */        for (i=0 ; i&lt;MULTITHREAD; i++) &#123;                if (results[i].execs &amp; ID_LIST) &#123;                        results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);                &#125;                if (results[i].execs &amp; ID_MATRIX) &#123;                        core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) &lt;&lt; 16), &amp;(results[i].mat) );                &#125;                if (results[i].execs &amp; ID_STATE) &#123;                        core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);                &#125;        &#125;/* 自动确定迭代次数 至少10s */        if (results[0].iterations==0) &#123;                secs_ret secs_passed=0;                ee_u32 divisor;                results[0].iterations=1;                while (secs_passed &lt; (secs_ret)1) &#123;                        results[0].iterations*=10;                        start_time();                        iterate(&amp;results[0]);                        stop_time();                        secs_passed=time_in_secs(get_time());                &#125;                /* now we know it executes for at least 1 sec, set actual run time at about 10 secs */                divisor=(ee_u32)secs_passed;                if (divisor==0) /* some machines cast float to int as 0 since this conversion is not defined by ANSI, but we know at least one second passed */                        divisor=1;                results[0].iterations*=1+10/divisor;        &#125;//根据不同CRC统计值得到不同的执行模式，2k/6k/profile/performance/validata  switch (seedcrc) &#123; /* test known output for common seeds */                case 0x8a02: /* seed1=0, seed2=0, seed3=0x66, size 2000 per algorithm */                        known_id=0;                        ee_printf(&quot;6k performance run parameters for coremark.\\n&quot;);                        break;                case 0x7b05: /*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 2000 per algorithm */                        known_id=1;                        ee_printf(&quot;6k validation run parameters for coremark.\\n&quot;);                        break;                case 0x4eaf: /* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm */                        known_id=2;                        ee_printf(&quot;Profile generation run parameters for coremark.\\n&quot;);                        break;                case 0xe9f5: /* seed1=0, seed2=0, seed3=0x66, size 666 per algorithm */                        known_id=3;                        ee_printf(&quot;2K performance run parameters for coremark.\\n&quot;);                        break;                case 0x18f2: /*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 666 per algorithm */                        known_id=4;                        ee_printf(&quot;2K validation run parameters for coremark.\\n&quot;);                        break;                default:                        total_errors=-1;                        break;        &#125;/* 打印结果 */        ee_printf(&quot;CoreMark Size    : %lu\\n&quot;, (long unsigned) results[0].size);        ee_printf(&quot;Total ticks      : %lu\\n&quot;, (long unsigned) total_time);#if HAS_FLOAT        ee_printf(&quot;Total time (secs): %f\\n&quot;,time_in_secs(total_time));        if (time_in_secs(total_time) &gt; 0)                ee_printf(&quot;Iterations/Sec   : %f\\n&quot;,default_num_contexts*results[0].iterations/time_in_secs(total_time));#else        ee_printf(&quot;Total time (secs): %d\\n&quot;,time_in_secs(total_time));        if (time_in_secs(total_time) &gt; 0)                ee_printf(&quot;Iterations/Sec   : %d\\n&quot;,default_num_contexts*results[0].iterations/time_in_secs(total_time));#endif        if (time_in_secs(total_time) &lt; 10) &#123;                ee_printf(&quot;ERROR! Must execute for at least 10 secs for a valid result!\\n&quot;);                total_errors++;        &#125;\n\n​coremark.h\ncall_bench_list&#x2F;matrix&#x2F;state()是benchmark的执行函数，和result[i].exe一起控制测试程序的执行\ncoremark_list_join.c&#x2F;matrix.c&#x2F;state.c&#x2F;util.c分别为各自benchmark和CRC函数所在的源文件\ncore_portme.c修改的地方\n/* setting to 1/1000 of a second resolution by default with linux */        #ifndef TIMER_RES_DIVIDER        #define TIMER_RES_DIVIDER 1000000        #endif        #define SAMPLE_TIME_IMPLEMENTATION 1#else    // 加入RISCV部分    #define NSECS_PER_SEC 500000000         #define EE_TIMER_TICKER_RATE 1000         #define CORETIMETYPE clock_t    #define read_csr(reg) (&#123; unsigned long __tmp; \\       asm volatile (&quot;csrr %0, &quot; #reg : &quot;=r&quot;(__tmp)); \\       __tmp; &#125;)    #define GETMYTIME(_t) (*_t=read_csr(cycle))//通过读时钟周期计数        #define MYTIMEDIFF(fin,ini) ((fin)-(ini))        #define TIMER_RES_DIVIDER 1        #define SAMPLE_TIME_IMPLEMENTATION 1#endif#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)\n这段代码是一个条件编译块，用于设置不同平台上计时器分辨率和实现细节。不同的编译分支适用于Linux系统和RISCV架构。其中包括cpu频率和定时器频率的设置，根据具体硬件特性确定。\ncore_portme.h修改的地方\n\n如果定义了宏HAS_TIME_H，这表明该平台具有并支持time.h标准C库头文件。在这个分支中，CORE_TICKS被定义为clock_t，这是time.h中定义的一个类型，通常用于计算程序占用的处理器时间。但是RISCV-baremetal不用标准库，用newlabc\n手动定义了size_t和clock_t为unsigned long int类型，并将CORE_TICKS设置为clock_t。用于baremetal，这些类型的大小需要匹配处理器输出的时钟大小和处理器支持的位数（xLen）。\n\n/* Configuration: CORE_TICKS        Define type of return from the timing functions. */#if defined(_MSC_VER)#include &lt;windows.h&gt;typedef size_t CORE_TICKS;#elif HAS_TIME_H#include &lt;time.h&gt;typedef clock_t CORE_TICKS;#else/* Configuration: size_t and clock_t     Note these need to match the size of the clock output and the xLen the processor supports */typedef unsigned long int size_t;typedef unsigned long int clock_t;typedef clock_t CORE_TICKS;#endif\ncore_portme.mak修改的地方\n设置RISCV工具链和路径，编译选项不变\n# Flag: RISCVTOOLS#       Use this flag to point to your RISCV toolsRISCVTOOLS=$(RISCV)# Flag: RISCVTYPE#   Type of toolchain to useRISCVTYPE=riscv64-unknown-elf# Flag: OUTFLAG#       Use this flag to define how to to get an executable (e.g -o)OUTFLAG= -o# Flag: CC#       Use this flag to define compiler to useCC = $(RISCVTOOLS)/bin/$(RISCVTYPE)-gcc# Flag: CFLAGS#       Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS=&quot;other flags&quot;#PORT_CFLAGS = -O2 -static -std=gnu99PORT_CFLAGS = -O2FLAGS_STR = &quot;$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)&quot;CFLAGS = $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\\&quot;$(FLAGS_STR)\\&quot;\n跑10000000cycle，需要大概50min，跑通100次iteration，91830000cycle，大概需要460min&#x3D;7小时40min。跑通了coremark，接下来需要加速跑的时间和利用它来评估设计（比如cache miss rate），要进一步看懂code。\n总结一下遇到的问题，解决的方法和完成的工作：\n1.用gdb跑了一遍在Linux上跑的coremark，熟悉代码；\n2.遇到的问题：\na.仿真停在某一条指令，停在一条很正常的函数ret的压栈出栈指令。\n-&gt;看rocket code，结合波形，发现是id_is_returngood的问题，之前师兄熟悉rocket代码加的指令，删掉就可以继续跑了；\nb.跑到10000001cycle之后，不能继续跑。\n-&gt;看.out输出 failed，没有正常退出，看.make_coremark.log(makefile输出的)报错，timeout，定位到test_driver.v函数，发现是max_cycle到极限了。如何改max_cycle？去看makefile，即可定位到variable.mak文件里面的CFLAGS变量，在里面修改timeout_cycles的值为100000000即可，实测90000000cycle，iterate 100 times，结果是可以的。\nc.结果的tick value得到了，但是sec value没有得到，应该是time_in_secs函数出问题了，到portme.c文件去找问题。log是sec没有10 s\n从portme.c可得，1000000000ticks&#x3D;1s,45589522ticks&#x3D;0.05s左右，也就是50ms.\n    #define NSECS_PER_SEC 1000000000 // normal        #define EE_TIMER_TICKER_RATE 1000 // set for 1ms        #define CORETIMETYPE clock_t    #define read_csr(reg) (&#123; unsigned long __tmp; \\       asm volatile (&quot;csrr %0, &quot; #reg : &quot;=r&quot;(__tmp)); \\       __tmp; &#125;)    #define GETMYTIME(_t) (*_t=read_csr(cycle))        #define MYTIMEDIFF(fin,ini) ((fin)-(ini))        #define TIMER_RES_DIVIDER 1        #define SAMPLE_TIME_IMPLEMENTATION 1#endif#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)\n3.可以深入探究的：\na.bare-metal怎么实现内存分配的？\n(gdb) n143\t\t\t\tresults[i].size=malloc_override;(gdb) n146\t\t\tresults[i].memblock[0]=portable_malloc(results[i].size);(gdb) info localsmalloc_override = 2000i = 0j = 0num_algorithms = 0known_id = -1total_errors = 0seedcrc = 0total_time = &lt;optimized out&gt;results = &#123;&#123;seed1 = 0, seed2 = 0, seed3 = 102, memblock = &#123;0x0, 0x0, 0x0, 0x7fffffffde00&#125;, size = 2000, iterations = 0, execs = 7, list = 0x7ffff78abd8d &lt;intel_check_word+173&gt;,     mat = &#123;N = 8388608, A = 0xffffffffffffffff, B = 0x7ffff75ef8f0 &lt;sighandler_setxid&gt;, C = 0xf0&#125;, crc = 1, crclist = 0, crcmatrix = 0, crcstate = 0, err = 9101, port = &#123;      portable_id = 1 &#x27;\\001&#x27;&#125;&#125;&#125;(gdb) sportable_malloc (size=2000) at linux64/core_portme.c:3232\t\treturn malloc(size);\nlinux是通过上述过程实现的，也就是melloc()函数，分配给的size空间为2000.\n如果想要知道bare-metal怎么分配内存，可能要去看.out和.dump结合理解，好麻烦，，，后面看吧\nb.bare-metal怎么用定时器计数的？没有syscall&#x2F;ecall的情况下（如果有rt-thread类似简单的os有ecall）\n上述代码定义了csrr内联汇编指令，可以读取寄存器的值得到cycle。\n//gdb debug(gdb) bt#0  main (argc=8, argv=0x7fffffffdee8) at core_main.c:203(gdb) sstart_time () at linux64/core_portme.c:125125\t\tGETMYTIME(&amp;start_time_val );      (gdb) s__GI___clock_gettime (clock_id=0, tp=0x6040b0 &lt;start_time_val&gt;) at ../sysdeps/unix/clock_gettime.c:93(gdb) s115\t      SYSDEP_GETTIME_CPU (clock_id, tp);//get secssecs_ret time_in_secs(CORE_TICKS ticks) &#123;        secs_ret retval=((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;        return retval;&#125;CORE_TICKS get_time(void) &#123;        CORE_TICKS elapsed=(CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));        return elapsed;&#125;//RISCV-baremetal   #define read_csr(reg) (&#123; unsigned long __tmp; \\       asm volatile (&quot;csrr %0, &quot; #reg : &quot;=r&quot;(__tmp)); \\       __tmp; &#125;)    #define GETMYTIME(_t) (*_t=read_csr(cycle))\nc.里面有3个子workload，执行过程是什么样的？\n全跑的话，results[0].exes value是7。如果想要只执行某一个，设置这个参数就可以了。\n而且，与猜想的一样，bench_list就是整理3个benchmark的数据，里面可以跳转到calc_func执行matrix_cal和state_cal。\n83 /* Algorithm IDS */84 #define ID_LIST         (1&lt;&lt;0)85 #define ID_MATRIX       (1&lt;&lt;1)86 #define ID_STATE        (1&lt;&lt;2)87 #define ALL_ALGORITHMS_MASK (ID_LIST|ID_MATRIX|ID_STATE)88 #define NUM_ALGORITHMS 3\n\n","slug":"coremark tutorial","date":"2024-03-18T10:49:37.000Z","categories_index":"文档","tags_index":"文档","author_index":"rain"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-03-18T10:49:30.000Z","categories_index":"文档","tags_index":"文档","author_index":"shiroha"}]