<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Coremark Tutorial &mdash; SEU-ACAL Document v1 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=3a60158e"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../_static/translations.js?v=beaddf03"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="工程介绍" href="Project.html" />
    <link rel="prev" title="工具链配置" href="tool-chain-document.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SEU-ACAL Document
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tool-chain-document.html">工具链配置</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Coremark Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">背景</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">使用方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">源码阅读</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#coremark-main-c">coremark_main.c</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coremark-h">​coremark.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-portme-h">core_portme.h修改的地方</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-portme-mak">core_portme.mak修改的地方</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Project.html">工程介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="Lecture-notes.html">课程讲义</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SEU-ACAL Document</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Coremark Tutorial</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/pages/Coremark Tutorial.rst.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="coremark-tutorial">
<h1>Coremark Tutorial<a class="headerlink" href="#coremark-tutorial" title="此标题的永久链接"></a></h1>
<section id="id1">
<h2>背景<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p>CoreMark是由EEMBC(Embedded Microprocessor Benchmark Consortium)的Shay Gla-On于2009年提出的一项基准测试程序，CoreMark的主要目标是简化操作，并提供一套测试单核处理器核心的方法。</p>
<p>测试标准是在配置参数的组合下单位时间内运行的CoreMark程序次数（单位：CoreMark/MHz），该数字值越大则说明测试的性能越好。</p>
<p>CoreMark是一个简单但复杂的基准测试，专门设计用于测试处理器核心的功能。运行CoreMark会生成一个单一的评分，使用户能够快速比较处理器之间的差异。目前嵌入式CPU行业中普遍公认的性能测试指标包括：MIPS/Dhrystone/CoreMark。
与Dhrystone类似，CoreMark也是小巧、便携、易于理解、免费，并且显示一个单一的基准测试分数。与Dhrystone不同的是，CoreMark有特定的运行和报告规则，并且旨在避免Dhrystone存在的问题，即由于使用的编译库不同而导致测试结果难以比较。</p>
<p>例如，Dhrystone的主要部分实际上是展示了编译器优化工作负载的能力，而不是MCU或CPU的能力。因此，Dhrystone更多地被用作编译器基准测试，而不是硬件基准测试。</p>
<p>同样，在Dhrystone的计时部分内部进行库调用。通常，这些库调用会占据基准测试消耗时间的大部分。由于库代码不是基准测试的一部分，如果使用不同的库进行比较，很难得出准确结果。最后，关于如何运行Dhrystone存在一些指导方针，但由于结果没有经过认证或验证，这些指南并不强制执行。关于如何报告Dhrystone结果也没有标准化，存在着各种不同的格式（如DMIPS、每秒Dhrystones、DMIPS/MHz）。</p>
</section>
<section id="id2">
<h2>使用方法<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h2>
<p>根据eembc官方说的方法，如果想要在risc-v运行toolchain，需要在core_portme.c/.h/.mak这几个源文件作修改。</p>
</section>
<section id="id3">
<h2>源码阅读<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h2>
<section id="coremark-main-c">
<h3>coremark_main.c<a class="headerlink" href="#coremark-main-c" title="此标题的永久链接"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">//内存分配 包括stack/static/malloc三种方式</span>
<span class="cp">#elif (MEM_METHOD==MEM_STACK)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">MULTITHREAD</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memblock</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">stack_memblock</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="n">TOTAL_DATA_SIZE</span><span class="p">;</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="o">=</span><span class="n">TOTAL_DATA_SIZE</span><span class="p">;</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">seed1</span><span class="o">=</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">seed1</span><span class="p">;</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">seed2</span><span class="o">=</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">seed2</span><span class="p">;</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">seed3</span><span class="o">=</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">seed3</span><span class="p">;</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">err</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">execs</span><span class="o">=</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">execs</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="cm">/* 初始化3个benchmark */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">MULTITHREAD</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">execs</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ID_LIST</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="o">=</span><span class="n">core_list_init</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">,</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memblock</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">seed1</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">execs</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ID_MATRIX</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">core_init_matrix</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memblock</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="n">ee_s32</span><span class="p">)</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">seed1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(((</span><span class="n">ee_s32</span><span class="p">)</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">seed2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mat</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">execs</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ID_STATE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">core_init_state</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">,</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">seed1</span><span class="p">,</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memblock</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="cm">/* 自动确定迭代次数 至少10s */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iterations</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">secs_ret</span><span class="w"> </span><span class="n">secs_passed</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="n">ee_u32</span><span class="w"> </span><span class="n">divisor</span><span class="p">;</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">secs_passed</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">secs_ret</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iterations</span><span class="o">*=</span><span class="mi">10</span><span class="p">;</span>
<span class="w">                        </span><span class="n">start_time</span><span class="p">();</span>
<span class="w">                        </span><span class="n">iterate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">                        </span><span class="n">stop_time</span><span class="p">();</span>
<span class="w">                        </span><span class="n">secs_passed</span><span class="o">=</span><span class="n">time_in_secs</span><span class="p">(</span><span class="n">get_time</span><span class="p">());</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="cm">/* now we know it executes for at least 1 sec, set actual run time at about 10 secs */</span>
<span class="w">                </span><span class="n">divisor</span><span class="o">=</span><span class="p">(</span><span class="n">ee_u32</span><span class="p">)</span><span class="n">secs_passed</span><span class="p">;</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">divisor</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="cm">/* some machines cast float to int as 0 since this conversion is not defined by ANSI, but we know at least one second passed */</span>
<span class="w">                        </span><span class="n">divisor</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="w">                </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iterations</span><span class="o">*=</span><span class="mi">1</span><span class="o">+</span><span class="mi">10</span><span class="o">/</span><span class="n">divisor</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="c1">//根据不同CRC统计值得到不同的执行模式，2k/6k/profile/performance/validata</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">seedcrc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* test known output for common seeds */</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="mh">0x8a02</span><span class="p">:</span><span class="w"> </span><span class="cm">/* seed1=0, seed2=0, seed3=0x66, size 2000 per algorithm */</span>
<span class="w">                        </span><span class="n">known_id</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">                        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;6k performance run parameters for coremark.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="mh">0x7b05</span><span class="p">:</span><span class="w"> </span><span class="cm">/*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 2000 per algorithm */</span>
<span class="w">                        </span><span class="n">known_id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="w">                        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;6k validation run parameters for coremark.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="mh">0x4eaf</span><span class="p">:</span><span class="w"> </span><span class="cm">/* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm */</span>
<span class="w">                        </span><span class="n">known_id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="w">                        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;Profile generation run parameters for coremark.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="mh">0xe9f5</span><span class="p">:</span><span class="w"> </span><span class="cm">/* seed1=0, seed2=0, seed3=0x66, size 666 per algorithm */</span>
<span class="w">                        </span><span class="n">known_id</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="w">                        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;2K performance run parameters for coremark.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="mh">0x18f2</span><span class="p">:</span><span class="w"> </span><span class="cm">/*  seed1=0x3415, seed2=0x3415, seed3=0x66, size 666 per algorithm */</span>
<span class="w">                        </span><span class="n">known_id</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
<span class="w">                        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;2K validation run parameters for coremark.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="k">default</span><span class="o">:</span>
<span class="w">                        </span><span class="n">total_errors</span><span class="o">=</span><span class="mi">-1</span><span class="p">;</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>


<span class="cm">/* 打印结果 */</span>
<span class="w">        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;CoreMark Size    : %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">)</span><span class="w"> </span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;Total ticks      : %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">)</span><span class="w"> </span><span class="n">total_time</span><span class="p">);</span>
<span class="cp">#if HAS_FLOAT</span>
<span class="w">        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;Total time (secs): %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">time_in_secs</span><span class="p">(</span><span class="n">total_time</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">time_in_secs</span><span class="p">(</span><span class="n">total_time</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;Iterations/Sec   : %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">default_num_contexts</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iterations</span><span class="o">/</span><span class="n">time_in_secs</span><span class="p">(</span><span class="n">total_time</span><span class="p">));</span>
<span class="cp">#else</span>
<span class="w">        </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;Total time (secs): %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">time_in_secs</span><span class="p">(</span><span class="n">total_time</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">time_in_secs</span><span class="p">(</span><span class="n">total_time</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;Iterations/Sec   : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">default_num_contexts</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iterations</span><span class="o">/</span><span class="n">time_in_secs</span><span class="p">(</span><span class="n">total_time</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">time_in_secs</span><span class="p">(</span><span class="n">total_time</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">ee_printf</span><span class="p">(</span><span class="s">&quot;ERROR! Must execute for at least 10 secs for a valid result!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="n">total_errors</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="coremark-h">
<h3>​coremark.h<a class="headerlink" href="#coremark-h" title="此标题的永久链接"></a></h3>
<p>call_bench_list/matrix/state()是benchmark的执行函数，和result[i].exe一起控制测试程序的执行
coremark_list_join.c/matrix.c/state.c/util.c分别为各自benchmark和CRC函数所在的源文件
core_portme.c修改的地方:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* setting to 1/1000 of a second resolution by default with linux */</span>
<span class="w">        </span><span class="cp">#ifndef TIMER_RES_DIVIDER</span>
<span class="w">        </span><span class="cp">#define TIMER_RES_DIVIDER 1000000</span>
<span class="w">        </span><span class="cp">#endif</span>
<span class="w">        </span><span class="cp">#define SAMPLE_TIME_IMPLEMENTATION 1</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="c1">// 加入RISCV部分</span>
<span class="w">    </span><span class="cp">#define NSECS_PER_SEC 500000000</span>
<span class="w">        </span><span class="cp">#define EE_TIMER_TICKER_RATE 1000</span>
<span class="w">        </span><span class="cp">#define CORETIMETYPE clock_t</span>
<span class="w">    </span><span class="cp">#define read_csr(reg) ({ unsigned long __tmp; \</span>
<span class="cp">    asm volatile (&quot;csrr %0, &quot; #reg : &quot;=r&quot;(__tmp)); \</span>
<span class="cp">    __tmp; })</span>
<span class="w">    </span><span class="cp">#define GETMYTIME(_t) (*_t=read_csr(cycle))</span><span class="c1">//通过读时钟周期计数</span>
<span class="w">        </span><span class="cp">#define MYTIMEDIFF(fin,ini) ((fin)-(ini))</span>
<span class="w">        </span><span class="cp">#define TIMER_RES_DIVIDER 1</span>
<span class="w">        </span><span class="cp">#define SAMPLE_TIME_IMPLEMENTATION 1</span>
<span class="cp">#endif</span>
<span class="cp">#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)</span>
</pre></div>
</div>
<p>这段代码是一个条件编译块，用于设置不同平台上计时器分辨率和实现细节。不同的编译分支适用于Linux系统和RISCV架构。其中包括cpu频率和定时器频率的设置，根据具体硬件特性确定。</p>
</section>
<section id="core-portme-h">
<h3>core_portme.h修改的地方<a class="headerlink" href="#core-portme-h" title="此标题的永久链接"></a></h3>
<p>如果定义了宏HAS_TIME_H，这表明该平台具有并支持time.h标准C库头文件。在这个分支中，CORE_TICKS被定义为clock_t，这是time.h中定义的一个类型，通常用于计算程序占用的处理器时间。但是RISCV-baremetal不用标准库，用newlabc
手动定义了size_t和clock_t为unsigned long int类型，并将CORE_TICKS设置为clock_t。用于baremetal，这些类型的大小需要匹配处理器输出的时钟大小和处理器支持的位数（xLen）。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Configuration: CORE_TICKS</span>
<span class="cm">        Define type of return from the timing functions.</span>
<span class="cm">*/</span>
<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;windows.h&gt;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">CORE_TICKS</span><span class="p">;</span>
<span class="cp">#elif HAS_TIME_H</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">CORE_TICKS</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cm">/* Configuration: size_t and clock_t</span>
<span class="cm">Note these need to match the size of the clock output and the xLen the processor supports</span>
<span class="cm">*/</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">size_t</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">clock_t</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">CORE_TICKS</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
<section id="core-portme-mak">
<h3>core_portme.mak修改的地方<a class="headerlink" href="#core-portme-mak" title="此标题的永久链接"></a></h3>
<p>设置RISCV工具链和路径，编译选项不变</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Flag: RISCVTOOLS</span>
<span class="c1">#       Use this flag to point to your RISCV tools</span>
<span class="nv">RISCVTOOLS</span><span class="o">=</span><span class="k">$(</span>RISCV<span class="k">)</span>
<span class="c1"># Flag: RISCVTYPE</span>
<span class="c1">#   Type of toolchain to use</span>
<span class="nv">RISCVTYPE</span><span class="o">=</span>riscv64-unknown-elf
<span class="c1"># Flag: OUTFLAG</span>
<span class="c1">#       Use this flag to define how to to get an executable (e.g -o)</span>
<span class="nv">OUTFLAG</span><span class="o">=</span><span class="w"> </span>-o
<span class="c1"># Flag: CC</span>
<span class="c1">#       Use this flag to define compiler to use</span>
<span class="nv">CC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">$(</span>RISCVTOOLS<span class="k">)</span>/bin/<span class="k">$(</span>RISCVTYPE<span class="k">)</span>-gcc
<span class="c1"># Flag: CFLAGS</span>
<span class="c1">#       Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS=&quot;other flags&quot;</span>
<span class="c1">#PORT_CFLAGS = -O2 -static -std=gnu99</span>
<span class="nv">PORT_CFLAGS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>-O2
<span class="nv">FLAGS_STR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>PORT_CFLAGS<span class="k">)</span><span class="s2"> </span><span class="k">$(</span>XCFLAGS<span class="k">)</span><span class="s2"> </span><span class="k">$(</span>XLFLAGS<span class="k">)</span><span class="s2"> </span><span class="k">$(</span>LFLAGS_END<span class="k">)</span><span class="s2">&quot;</span>
<span class="nv">CFLAGS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">$(</span>PORT_CFLAGS<span class="k">)</span><span class="w"> </span>-I<span class="k">$(</span>PORT_DIR<span class="k">)</span><span class="w"> </span>-I.<span class="w"> </span>-DFLAGS_STR<span class="o">=</span><span class="se">\&quot;</span><span class="k">$(</span>FLAGS_STR<span class="k">)</span><span class="se">\&quot;</span>
</pre></div>
</div>
<p>跑10000000cycle，需要大概50min，跑通100次iteration，91830000cycle，大概需要460min=7小时40min。跑通了coremark，接下来需要加速跑的时间和利用它来评估设计（比如cache miss rate），要进一步看懂code。</p>
<p>总结一下遇到的问题，解决的方法和完成的工作：</p>
<p>1.用gdb跑了一遍在Linux上跑的coremark，熟悉代码；</p>
<p>2.遇到的问题：</p>
<p>a.仿真停在某一条指令，停在一条很正常的函数ret的压栈出栈指令。</p>
<blockquote>
<div><p>看rocket code，结合波形，发现是id_is_returngood的问题，之前师兄熟悉rocket代码加的指令，删掉就可以继续跑了；</p>
</div></blockquote>
<p>b.跑到10000001cycle之后，不能继续跑。</p>
<blockquote>
<div><p>看.out输出 failed，没有正常退出，看.make_coremark.log(makefile输出的)报错，timeout，定位到test_driver.v函数，发现是max_cycle到极限了。如何改max_cycle？去看makefile，即可定位到variable.mak文件里面的CFLAGS变量，在里面修改timeout_cycles的值为100000000即可，实测90000000cycle，iterate 100 times，结果是可以的。</p>
</div></blockquote>
<p>c.结果的tick value得到了，但是sec value没有得到，应该是time_in_secs函数出问题了，到portme.c文件去找问题。log是sec没有10 s</p>
<p>从portme.c可得，1000000000ticks=1s,45589522ticks=0.05s左右，也就是50ms.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define NSECS_PER_SEC 1000000000 </span><span class="c1">// normal</span>
<span class="w">    </span><span class="cp">#define EE_TIMER_TICKER_RATE 1000 </span><span class="c1">// set for 1ms</span>
<span class="w">    </span><span class="cp">#define CORETIMETYPE clock_t</span>
<span class="cp">#define read_csr(reg) ({ unsigned long __tmp; \</span>
<span class="cp">   asm volatile (&quot;csrr %0, &quot; #reg : &quot;=r&quot;(__tmp)); \</span>
<span class="cp">   __tmp; })</span>
<span class="cp">#define GETMYTIME(_t) (*_t=read_csr(cycle))</span>
<span class="w">    </span><span class="cp">#define MYTIMEDIFF(fin,ini) ((fin)-(ini))</span>
<span class="w">    </span><span class="cp">#define TIMER_RES_DIVIDER 1</span>
<span class="w">    </span><span class="cp">#define SAMPLE_TIME_IMPLEMENTATION 1</span>
<span class="w">    </span><span class="cp">#endif</span>
<span class="w">    </span><span class="cp">#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)</span>
</pre></div>
</div>
<p>3.可以深入探究的：</p>
<p>a.bare-metal怎么实现内存分配的？</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>n
<span class="m">143</span><span class="w">                             </span>results<span class="o">[</span>i<span class="o">]</span>.size<span class="o">=</span>malloc_override<span class="p">;</span>
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>n
<span class="m">146</span><span class="w">                     </span>results<span class="o">[</span>i<span class="o">]</span>.memblock<span class="o">[</span><span class="m">0</span><span class="o">]=</span>portable_malloc<span class="o">(</span>results<span class="o">[</span>i<span class="o">]</span>.size<span class="o">)</span><span class="p">;</span>
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>info<span class="w"> </span>locals
<span class="nv">malloc_override</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2000</span>
<span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>
<span class="nv">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>
<span class="nv">num_algorithms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>
<span class="nv">known_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>-1
<span class="nv">total_errors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>
<span class="nv">seedcrc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>
<span class="nv">total_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>&lt;optimized<span class="w"> </span>out&gt;
<span class="nv">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{ {</span><span class="nv">seed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="nv">seed2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="nv">seed3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">102</span>,<span class="w"> </span><span class="nv">memblock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span>0x0,<span class="w"> </span>0x0,<span class="w"> </span>0x0,<span class="w"> </span>0x7fffffffde00<span class="o">}</span>,<span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2000</span>,<span class="w"> </span><span class="nv">iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="nv">execs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">7</span>,<span class="w"> </span><span class="nv">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>0x7ffff78abd8d<span class="w"> </span>&lt;intel_check_word+173&gt;,
<span class="nv">mat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="nv">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">8388608</span>,<span class="w"> </span><span class="nv">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>0xffffffffffffffff,<span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>0x7ffff75ef8f0<span class="w"> </span>&lt;sighandler_setxid&gt;,<span class="w"> </span><span class="nv">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>0xf0<span class="o">}</span>,<span class="w"> </span><span class="nv">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="nv">crclist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="nv">crcmatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="nv">crcstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">9101</span>,<span class="w"> </span><span class="nv">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="nv">portable_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="s1">&#39;\001&#39;</span><span class="o">}}}</span>
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>s
portable_malloc<span class="w"> </span><span class="o">(</span><span class="nv">size</span><span class="o">=</span><span class="m">2000</span><span class="o">)</span><span class="w"> </span>at<span class="w"> </span>linux64/core_portme.c:32
<span class="m">32</span><span class="w">              </span><span class="k">return</span><span class="w"> </span>malloc<span class="o">(</span>size<span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>linux是通过上述过程实现的，也就是melloc()函数，分配给的size空间为2000.
如果想要知道bare-metal怎么分配内存，可能要去看.out和.dump结合理解，好麻烦，，，后面看吧</p>
<p>b.bare-metal怎么用定时器计数的？没有syscall/ecall的情况下（如果有rt-thread类似简单的os有ecall）
上述代码定义了csrr内联汇编指令，可以读取寄存器的值得到cycle。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>bt
<span class="c1">#0  main (argc=8, argv=0x7fffffffdee8) at core_main.c:203</span>
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>s
start_time<span class="w"> </span><span class="o">()</span><span class="w"> </span>at<span class="w"> </span>linux64/core_portme.c:125
<span class="m">125</span><span class="w">             </span>GETMYTIME<span class="o">(</span><span class="p">&amp;</span>start_time_val<span class="w"> </span><span class="o">)</span><span class="p">;</span>
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>s
__GI___clock_gettime<span class="w"> </span><span class="o">(</span><span class="nv">clock_id</span><span class="o">=</span><span class="m">0</span>,<span class="w"> </span><span class="nv">tp</span><span class="o">=</span>0x6040b0<span class="w"> </span>&lt;start_time_val&gt;<span class="o">)</span><span class="w"> </span>at<span class="w"> </span>../sysdeps/unix/clock_gettime.c:93
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>s
<span class="m">115</span><span class="w">           </span>SYSDEP_GETTIME_CPU<span class="w"> </span><span class="o">(</span>clock_id,<span class="w"> </span>tp<span class="o">)</span><span class="p">;</span>
//get<span class="w"> </span>secs
secs_ret<span class="w"> </span>time_in_secs<span class="o">(</span>CORE_TICKS<span class="w"> </span>ticks<span class="o">)</span><span class="w"> </span><span class="o">{</span>
secs_ret<span class="w"> </span><span class="nv">retval</span><span class="o">=((</span>secs_ret<span class="o">)</span>ticks<span class="o">)</span><span class="w"> </span>/<span class="w"> </span><span class="o">(</span>secs_ret<span class="o">)</span>EE_TICKS_PER_SEC<span class="p">;</span>
<span class="k">return</span><span class="w"> </span>retval<span class="p">;</span>
<span class="o">}</span>
CORE_TICKS<span class="w"> </span>get_time<span class="o">(</span>void<span class="o">)</span><span class="w"> </span><span class="o">{</span>
CORE_TICKS<span class="w"> </span><span class="nv">elapsed</span><span class="o">=(</span>CORE_TICKS<span class="o">)(</span>MYTIMEDIFF<span class="o">(</span>stop_time_val,<span class="w"> </span>start_time_val<span class="o">))</span><span class="p">;</span>
<span class="k">return</span><span class="w"> </span>elapsed<span class="p">;</span>
<span class="o">}</span>
//RISCV-baremetal
<span class="c1">#define read_csr(reg) ({ unsigned long __tmp; \</span>
<span class="w">        </span>asm<span class="w"> </span>volatile<span class="w"> </span><span class="o">(</span><span class="s2">&quot;csrr %0, &quot;</span><span class="w"> </span><span class="c1">#reg : &quot;=r&quot;(__tmp)); \</span>
<span class="w">        </span>__tmp<span class="p">;</span><span class="w"> </span><span class="o">})</span>
<span class="c1">#define GETMYTIME(_t) (*_t=read_csr(cycle))</span>
</pre></div>
</div>
<p>c.里面有3个子workload，执行过程是什么样的？
全跑的话，results[0].exes value是7。如果想要只执行某一个，设置这个参数就可以了。
而且，与猜想的一样，bench_list就是整理3个benchmark的数据，里面可以跳转到calc_func执行matrix_cal和state_cal。</p>
<img alt="../_images/d027c7559a9c4dbca5b22547c8e4ad58.png" src="../_images/d027c7559a9c4dbca5b22547c8e4ad58.png" />
<img alt="../_images/5cef0796a98448d58211557b40bf22b2.png" src="../_images/5cef0796a98448d58211557b40bf22b2.png" />
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="tool-chain-document.html" class="btn btn-neutral float-left" title="工具链配置" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="Project.html" class="btn btn-neutral float-right" title="工程介绍" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2024, SEU-ACA。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>